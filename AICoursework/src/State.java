import java.util.ArrayList;
import java.util.Arrays;

public class State {

	//The Gridsize , NxN
	private int n;
	private int[][] curBoard;
	
	
	//takes an nxn board board and
	public State(int n, int[][] board)
	{
		this.n = n;
		curBoard = board;
		//calcWrongBlocks();
		//setManDist();
	}
	
	//checks if all the non agent blocks are in their goal positions
	public boolean isGoalState()
	{
		for (int i = 0; i < (n-1); i++)
		{
			//This checks if the value in the cell is correct
			//Because we want a largest at bottom of tower (where 1=a,2=b ...)
			//We must subtract i from n, and also subtract 1 again because 0 is our empty cell not a
			if (curBoard[1][i] != n-i-1)
			{
				return false;
			}
		}
		// if none of the blocks are wrong return true
		return true;
	}
	
	// Calculates the number of blocks not in their correct place
	// A simple heuristic which does not take into account blocks' distance from their goal position
	public int calcWrongBlocks()
	{
		int wrongBlocks = 0;
		// we don't iterate of the top space in the column
		for (int i = 0; i < (n-1); i++)
		{
			//This checks if the value in the cell is correct
			//Because we want a largest at bottom of tower (where 1=a,2=b ...)
			//We must subtract i from n, and also subtract 1 again because 0 is our empty cell not a
			if (curBoard[1][i] != n-i-1)
			{
				//is init to 0 globally
				wrongBlocks++;
			}
		}
		return wrongBlocks;
	}
	
	// This calculates the total distance between all blocks and where they are supposed to be
	// this is Delta x + Delta y distance, as we can't swap diagonally so this seems to make more sense
	// This is an more advanced heuristic, and is particularly effective as this is a problem where the cost
	// of any move is always 1
	public int calcDistance()
	{
		int totalDistance = 0;
		// we don't iterate over the top space in the column
		for (int y = 0; y < n; y++) {
			for (int x = 0; x < n; x++) {
				int val = curBoard[x][y];
				//If the block is not empty or the agent
				if(!(val == 0) || !(val == -1)) {
					//x distance is always from column 1 (indexed from 0)
					//we use the same calculation as in wrongBlocks to get the y distance
					int distance = (Math.abs(x-1)) + Math.abs(y - (n-val-1));
					totalDistance += distance;
				}
			}
		}
		return totalDistance;
	}
	
	// generates the Start State for the problem for an NxN grid
	public State(int n) {
		
	}
	
	//returns the position of the agent, represented by -1
	private Coord getAgent() {
		for (int x = 0; x < n; x++) {
			for (int y = 0; y <n; y++) {
				if (curBoard[x][y] == -1) {
					return new Coord(x,y);
				}
			}
		}
		//This would represent an error, as there should always be an agent on the board!
		return new Coord(-1,-1);
	}
	
	// creates a copy of a board so we can generate children
	private int[][] copyBoard(int[][] oldBoard)
	{
		int[][] newBoard = new int[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j <n; j++) {
				newBoard[i][j] = oldBoard[i][j];
			}
		}
		return newBoard;
	}
	
	//generates the children for a state, based on left, right, up and down moves
	public ArrayList<State> genChildren()
	{
		ArrayList<State> children = new ArrayList<State>();
		Coord agent = getAgent();

		//Try to slide the agent left
		if (agent.getX() > 0)
		{
			// genet
			storeChild(agent, new Coord(agent.getX()-1, agent.getY()), children);
		}
		
		// try to slide the agent right
		if (agent.getX() < (n-1))
		{
			storeChild(agent, new Coord(agent.getX()+1, agent.getY()), children);
		}

		// try to slide the agent up
		if (agent.getY() <(n-1))
		{
			storeChild(agent, new Coord(agent.getX(), agent.getY()+1), children);
		}

		// try to slide the agent down
		if (agent.getY() > 0)
		{
			storeChild(agent, new Coord(agent.getX(), agent.getY()-1), children);
		}
		

		return children;
	}
	
	// takes two block coords and the arraylist of child states and adds the state
	// generated by swapping the 2 blocks to the list.
	private void storeChild(Coord p1, Coord p2, ArrayList<State> s)
	{
		int[][] newBoard = copyBoard(curBoard);
		//swap the two blocks
		newBoard[p2.getX()][p2.getY()] = curBoard[p1.getX()][p1.getY()];
		newBoard[p1.getX()][p1.getY()] = curBoard[p2.getX()][p2.getY()];
		//add the new board state to the children array
		s.add(new State(n, newBoard));
	}
	
	// to check equality between two states
	//We need to use deepEquals because we are using 2d arrays
	public boolean equals(State s)
	{
		if (Arrays.deepEquals(curBoard, s.getCurBoard()))
		{
			return true;
		}
		else
			return false;

	}

	private int[][] getCurBoard() {
		return this.curBoard;
	}
	
	//prints out a  representation of the current board state
	public void printBoard() {
		
		System.out.println();
		System.out.println("----------------------------------------");
		
		// we iterate in reverse for y so we can print from the top left corner
		for (int y = n-1; y >= 0; y--) {
			for (int x = 0; x < n; x++) {
				int val = curBoard[x][y];
				String out = "";
				//This represents an empty block
				if (val == 0) out = "[]";
				// here A is agent
				else if (val == -1) out = "A";
				// and A, B, C... = 1, 2, 3...
				else out = Integer.toString(val);
				System.out.print(out + "\t");
			}
			System.out.println();
		}
		
		System.out.println("----------------------------------------");
		System.out.println();
	}
	
}
